<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 这个foo函数 调用时 ,在函数内部 再一次的调用 自己
      // 在调用函数时,函数内部又调用了自己,会导致无限的执行下去
      // 所以递归必须要有一个跳出条件,防止他无限执行
      // function foo(){
      //   console.log(1);
      //   foo();
      // }

      // foo();

      // pow(x,n)
      // 方式一  迭代思路
      function myPow(x, n) {
        var result = 1;
        for (var i = 1; i <= n; i++) {
          result *= x;
        }
        return result;
      }

      // function 递归思路

      function pow(x, n) {
        // (x的n次方) 等价于  (x的n-1次方*x)
        // return x的n次方
        // return x的n-1次方*x
        // 递归跳出条件
        if (n == 1) {
          return x;
        }
        // n==1 的时候 下边的代码不会执行
        return pow(x, n - 1) * x;
      }
      // 递归 会无限分解下去 ,所以一定要有跳出条件(就是在适当的时机,不再调用自己)
      // pow(3,4) ==>  pow(3,3) *3===>pow(3,2)*3 *3==>pow(3,1)*3 *3 *3==>pow(3,0)*3 *3 *3 *3==>....
      // pow(3,4) ==>  pow(3,3) *3===>pow(3,2)*3 *3==>pow(3,1)*3 *3 *3==>3*3 *3 *3==>
      console.log(pow(3, 4));

      // 利用递归求阶乘和
      // 明确jch(n) 求任意一个数的阶乘和

      // n! === (n-1)! *n
      function jc(n) {
        if (n == 1) {
          return 1;
        }
        return jc(n - 1) * n;
      }

      // n的阶乘和 == n-1的阶乘和 + n的阶乘
      function jch(n) {
        if (n == 1) {
          return 1;
        }
        return jch(n - 1) + jc(n);
      }
      console.log(jch(5));
      // jch(4)+jc(5)
      // jch(3)+jc(4)+ jc(4)*5
      // jch(2)+jc(3)+jc(3)*4+jc(3)*4*5
      // jch(1)+jc(2) + jc(2)*3 + jc(2)*3*4 + jc(2)*3*4*5
      // 1+ jc(1)*2 + jc(1)*2*3 +jc(1)*2*3*4  + jc(1)*2*3*4*5
      // 1 + 1*2  + 1*2*3 + 1*2*3*4 +1*2*3*4*5
    </script>
  </body>
</html>
